<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
  <ScriptPackage>
    <Script isActive="yes" isFolder="no">
        
      <name>func_lib</name>
      <script>function toggle_ddegroup()
  if ddeGroupContainer == nil then
    return
  end
  if persistent_variables[&quot;config&quot;][&quot;dde_group&quot;] == false then
    ddeGroupContainer:hide()
  else
    ddeGroupContainer:show()
  end
end

function file_exists(name)
  local f = io.open(name, &quot;r&quot;)
  if f ~= nil then
    io.close(f)
    return true
  else
    return false
  end
end

function string.starts(String, Start)
  return string.sub(String, 1, string.len(Start)) == Start
end

function firstToUpper(str)
  return (str:gsub(&quot;^%l&quot;, string.upper))
end

function explode(inputstr, sep)
  if sep == nil then
    sep = &quot;%s&quot;
  end
  local t = {}
  for str in string.gmatch(inputstr, &quot;([^&quot; .. sep .. &quot;]+)&quot;) do
    table.insert(t, str)
  end
  return t
end

function delete_table(x)
  for k in pairs(x) do
    x[k] = nil
  end
end

function merge_tables(old_table, new_table)
  table.foreach(
    old_table,
    function(k, v)
      table.insert(new_table, v)
    end
  )
end

function getAllyName(name)
  name = string.lower(name)
  if gmcp.Char.Gruppo.gruppo == nil then
    if string.starts(string.lower(gmcp.Char.Name.name), name) then
      return gmcp.Char.Name.name
    end
    return
  end
  local gruppo = gmcp.Char.Gruppo.gruppo
  for i, v in ipairs(gruppo) do
    v.nome = beautifyName(v.nome)
    if string.starts(string.lower(v.nome), name) then
      return v.nome
    end
  end
  return nil
end

--remove articles or other unnecessary names from followers

function beautifyName(name)
  if string.starts(string.lower(name), &quot;un enorme &quot;) then
    name = string.gsub(string.lower(name), &quot;un enorme &quot;, &quot;&quot;)
  elseif string.starts(string.lower(name), &quot;una &quot;) then
    name = string.gsub(string.lower(name), &quot;una &quot;, &quot;&quot;)
  elseif string.starts(string.lower(name), &quot;l&apos;&quot;) then
    name = string.gsub(string.lower(name), &quot;l&apos;&quot;, &quot;&quot;)
  elseif string.starts(string.lower(name), &quot;della &quot;) then
    name = string.gsub(string.lower(name), &quot;della &quot;, &quot;&quot;)
  elseif string.starts(string.lower(name), &quot;un &quot;) then
    name = string.gsub(string.lower(name), &quot;un &quot;, &quot;&quot;)
  elseif string.starts(string.lower(name), &quot;un&apos; &quot;) then
    name = string.gsub(string.lower(name), &quot;un&apos; &quot;, &quot;&quot;)
  end
  words = {}
  words[1], words[2] = name:match(&quot;(%w+)(%W+)&quot;)
  if words[1] == nil then
    words[1] = name
  end
  words[1] = firstToUpper(words[1])
  return words[1]
end

--remove duplicates from a table

function deduplicate(x)
  local seen = {}
  for index, item in ipairs(x) do
    if seen[item] then
      table.remove(x, index)
    else
      seen[item] = true
    end
  end
  if seen[&quot;nuovo vigore&quot;] then
    for k in pairs(x) do
      x[k] = nil
    end
    table.insert(x, &quot;nuovo vigore&quot;)
  end
end

function get_os()
  if package.config:sub(1, 1) == &quot;/&quot; then
    local f_os = assert(io.popen(&quot;uname&quot;, &apos;r&apos;))
    local s_os = assert(f_os:read(&apos;*a&apos;))
    f_os:close()
    if string.find(s_os, &quot;Linux&quot;) then
      return &quot;linux&quot;
    else
      return &quot;macos&quot;
    end
  end
  return &quot;window&quot;
end

function copy_to_clipboard(string)
  if persistent_variables[&quot;config&quot;][&quot;clipboard&quot;] == false then
    return
  end
  local os_name = get_os()
  if os_name == &quot;linux&quot; then
    local f = assert(io.popen(&quot;which xclip&quot;, &apos;r&apos;))
    local s = assert(f:read(&apos;*a&apos;))
    f:close()
    if s == &quot;&quot; then
      cecho(&quot;&lt;red&gt;\nERROR: command xclip not found!&quot;)
      cecho(&quot;&lt;red&gt;\nInstall with this command: sudo apt install xclip\n&quot;)
    else
      os.execute(&quot;echo -n \&quot;&quot; .. string .. &quot;\&quot; | xclip -selection clipboard&quot;)
    end
  elseif os_name == &quot;macos&quot; then
    os.execute(&quot;echo -n \&quot;&quot; .. string .. &quot;\&quot; | pbcopy&quot;)
  else
    os.execute(&apos;echo &apos; .. string .. &apos; | clip&apos;)
  end
end

function play_sound(file)
  if persistent_variables[&quot;config&quot;][&quot;sounds&quot;] == false then
    return
  end
  if get_os() == &quot;linux&quot; then
    local f = assert(io.popen(&quot;which paplay&quot;, &apos;r&apos;))
    local s = assert(f:read(&apos;*a&apos;))
    f:close()
    if s == &quot;&quot; then
      cecho(&quot;&lt;red&gt;\nERROR: command paplay not found!&quot;)
      cecho(&quot;&lt;red&gt;\nInstall with this command: sudo apt install pulseaudio-utils\n&quot;)
    else
      os.execute(&quot;paplay &quot; .. file .. &quot; &amp;&quot;)
    end
  else
    playSoundFile(file)
  end
end

function initialize_persistent_var(varname)
  if persistent_variables == nil then
    persistent_variables = {}
  end
  local savelocation = getMudletHomeDir() .. &quot;/&quot; .. varname .. &quot;.lua&quot;
  if persistent_variables[varname] == nil then
    persistent_variables[varname] = {}
  end
  if file_exists(savelocation) then
    table.load(savelocation, persistent_variables[varname])
  else
    save_persistent_var(varname)
  end
end

function save_persistent_var(varname)
  local savelocation = getMudletHomeDir() .. &quot;/&quot; .. varname .. &quot;.lua&quot;
  table.save(savelocation, persistent_variables[varname])
end

-- We need this function for sorting.

local function greater(a, b)
  return a[2] &gt; b[2]
end

-- Populate the array with key,value pairs from hashTable.

function makePairs(hashTable, array, _k)
  local k, v = next(hashTable, _k)
  if k then
    table.insert(array, {k, v})
    return makePairs(hashTable, array, k)
  end
end

-- Print the pairs from the array.

function printPairs(array, _i)
  local i = _i or 1
  local pair = array[i]
  if pair then
    local k, v = unpack(pair)
    print(k .. &apos;: &apos; .. os.date(&quot;%H:%M&quot;, v + 60 * 60))
    return printPairs(array, i + 1)
  end
end

function new_class()
  local class_table = {}
  class_table.buff = {dps = {}, tank = {}, base = {}}
  class_table.self_buff = {dps = {}, tank = {}, base = {}}
  class_table.move = {}
  class_table.heal = {}
  return class_table
end

--merge 2 classes table by table

function merge_classes(new_class, old_class)
  merge_tables(old_class.buff.dps, new_class.buff.dps)
  merge_tables(old_class.buff.tank, new_class.buff.tank)
  merge_tables(old_class.buff.base, new_class.buff.base)
  merge_tables(old_class.self_buff.dps, new_class.self_buff.dps)
  merge_tables(old_class.self_buff.tank, new_class.self_buff.tank)
  merge_tables(old_class.self_buff.base, new_class.self_buff.base)
  if old_class.heal ~= nil then
    merge_tables(old_class.heal, new_class.heal)
  end
  if old_class.move ~= nil then
    merge_tables(old_class.move, new_class.move)
  end
  if old_class.command ~= nil then
    new_class.command = old_class.command
  end
end

--remove duplicates from each class table

function deduplicate_class(class)
  deduplicate(class.buff.dps)
  deduplicate(class.buff.tank)
  deduplicate(class.buff.base)
  deduplicate(class.self_buff.dps)
  deduplicate(class.self_buff.tank)
  deduplicate(class.self_buff.base)
  deduplicate(class.move)
end

--generate spell list to observe based on player classes

function gen_spell_list(my_class_list)
  observe_spell_list = new_class()
  observe_spell_list.command = &quot;form&quot;
  for i, v in ipairs(my_class_list) do
    if class_list[v.classe] ~= nil then
      merge_classes(observe_spell_list, class_list[v.classe])
    end
  end
  deduplicate_class(observe_spell_list)
end

function removeFirstTwoWords(str)
  -- cerca la posizione della terza parola nella stringa
  local _, pos = string.find(str, &quot;%S+%s+%S+%s+&quot;)
  if pos then
    -- se la terza parola esiste, restituisce la parte rimanente della stringa
    return string.sub(str, pos + 1)
  else
    -- se la terza parola non esiste, restituisce una stringa vuota
    return &quot;&quot;
  end
end

function removeFirstWord(str)
  -- cerca la posizione della terza parola nella stringa
  local _, pos = string.find(str, &quot;%S+%s+&quot;)
  if pos then
    -- se la terza parola esiste, restituisce la parte rimanente della stringa
    return string.sub(str, pos + 1)
  else
    -- se la terza parola non esiste, restituisce una stringa vuota
    return &quot;&quot;
  end
end

function getPFcolor(current, max)
  local colors =
    {
      &quot;FF0000&quot;,
      &quot;ff3500&quot;,
      &quot;fc4f00&quot;,
      &quot;f86400&quot;,
      &quot;f27600&quot;,
      &quot;eb8700&quot;,
      &quot;e29700&quot;,
      &quot;d7a700&quot;,
      &quot;cab500&quot;,
      &quot;bbc300&quot;,
      &quot;aad000&quot;,
      &quot;96dc00&quot;,
      &quot;7de800&quot;,
      &quot;5bf400&quot;,
      &quot;00FF00&quot;,
    }
  color_index = math.floor((current * table.getn(colors) / max))
  if color_index &lt; 1 then
    color_index = 1
  elseif color_index &gt; table.getn(colors) then
    color_index = table.getn(colors)
  end
  return colors[color_index]
end

function role_list()
  return {&quot;base&quot;, &quot;tank&quot;, &quot;dps&quot;, &quot;tankdps&quot;, &quot;remove&quot;}
end

function ob_role(name, test_role, checkname)
  local roles = role_list()
  if checkname == true then
    allyName = getAllyName(name)
  else
    allyName = name
  end
  local role = &quot;&quot;
  if allyName ~= nil then
    for _, value in ipairs(roles) do
      if string.starts(value, test_role) then
        role = test_role
        break
      end
    end
    if role == &quot;&quot; then
      cecho(&quot;\n&lt;red&gt;Non è ammesso il valore &quot; .. test_role .. &quot;\n&quot;)
      echo(&quot;I ruoli ammessi sono: base, tank, dps, tankdps, remove\n&quot;)
      return false
    elseif role == &quot;remove&quot; then
      persistent_variables[character_name][&quot;observe_list&quot;][allyName] = nil
      echo(&quot;\n&quot; .. allyName .. &quot; non più in osservazione\n&quot;)
    else
      persistent_variables[character_name][&quot;observe_list&quot;][allyName] = role
      echo(&quot;\n&quot; .. allyName .. &quot; in osservazione come &quot; .. role .. &quot;\n&quot;)
    end
    send(&quot;\n&quot;)
    save_persistent_var(character_name)
    return true
  end
end

function set_char_permanent_var(varname, string)
  persistent_variables[character_name][varname] = string
  save_persistent_var(character_name)
end

function bool2str(bool)
  if bool then
    return &quot;&lt;green&gt;on&quot;
  end
  return &quot;&lt;red&gt;off&quot;
end

function str2bool(str)
  str = string.lower(str)
  if str == &quot;on&quot; or str == &quot;true&quot; or str == &quot;1&quot; or str == 1 then
    return true
  end
  return false
end

function show_config()
  checho(&quot;\nLa configurazione del profilo attuale è:&quot;)
  checho(&quot;\n   DdEGroup: &quot; .. bool2str(persistent_variables[&quot;config&quot;][&quot;dde_group&quot;]))
  checho(&quot;\n   Suoni: &quot; .. bool2str(persistent_variables[&quot;config&quot;][&quot;sounds&quot;]))
  checho(&quot;\n   Gloria: &quot; .. bool2str(persistent_variables[&quot;config&quot;][&quot;glory_timer&quot;]))
  checho(&quot;\n   Appunti: &quot; .. bool2str(persistent_variables[&quot;config&quot;][&quot;clipboard&quot;]))
  checho(
    &quot;\n   nascondi_scudoni: &quot; .. bool2str(persistent_variables[&quot;config&quot;][&quot;hide_immune_shield&quot;])
  )
  checho(
    &quot;\n   nascondi_px_persi: &quot; .. bool2str(persistent_variables[&quot;config&quot;][&quot;hide_lost_experience&quot;])
  )
  checho(&quot;\n\nLa configurazione del personaggio &lt;&quot; .. character_name .. &quot;&gt; è:&quot;)
  checho(&quot;\n   gdcolor_prefisso al gd: &quot; .. persistent_variables[character_name][&quot;gd_start&quot;])
  checho(&quot;\n   gdcolor_suffisso al gd: &quot; .. persistent_variables[character_name][&quot;gd_end&quot;])
end

function spam_main(string)
  local help_string =
    [[
Questo è l&apos;aiuto per SPAM (Seymour PAckage for Mudlet), un insieme
di alias, trigger e script per migliorare l&apos;esperienza di gioco
in Dei Delle Ere.
]]
  if string == &quot;&quot; then
    checho(help_string)
    show_config()
    checho(
      [[


Per avere maggiori informazioni su una impostazione usa: &lt;white&gt;spam nomeimpostazione&lt;gray&gt;
Ad esempio: &lt;white&gt;spam ddegroup &lt;gray&gt;oppure &lt;white&gt;spam gdcolor
]]
    )
  else
    split = explode(string)
    split[1] = string.lower(split[1])
    if #split == 1 then
      if string.starts(&quot;ddegroup&quot;, split[1]) then
        cecho(
          [[

DDEGroup è uno schermo per monitorare i buff dei compagni di gruppo.
Per abilitare/disabilitare DDEGroup usa il comando: &lt;white&gt;spam ddegroup on/off&lt;gray&gt;
Per controllare le ulteriori opzioni di DDEGroup usa il comando: &lt;white&gt;observe&lt;gray&gt;]]
        )
      elseif string.starts(&quot;suoni&quot;, split[1]) then
        cecho(
          [[

Alcune funzioni di SPAM potrebbero riprodurre dei suoni.
Per controllare la riproduzione dei suoni usa il comando: &lt;white&gt;spam suoni on/off]]
        )
      elseif string.starts(&quot;appunti&quot;, split[1]) then
        cecho(
          [[

SPAM intercetta i valuta mostri e le identificazioni e li copia negli appunti.
Per controllare l&apos;inserimento negli appunti usa il comando: &lt;white&gt;spam appunti on/off]]
        )
      elseif string.starts(&quot;nascondi_px_persi&quot;, split[1]) then
        cecho(
          [[

Per nascondere le righe che notificano la perdita di px oltre il livello usa il comando: &lt;white&gt;spam nascondi_px_persi on/off]]
        )
      elseif string.starts(&quot;nascondi_scudoni&quot;, split[1]) then
        cecho(
          [[

Per nascondere le righe sugli scudoni che NON colpiscono usa il comando: &lt;white&gt;spam nascondi_scudoni on/off]]
        )
      elseif string.starts(&quot;gloria&quot;, split[1]) then
        cecho(
          [[

La funzione Gloria permette di tenere traccia dei mob gloria uccisi nelle ultime 24 ore.
Per abilitare/disabilitare questa funzione usa il comando: &lt;white&gt;spam gloria on/off&lt;gray&gt;
Per mostrare i mob gloria uccisi nelle ultime 24 ore usa il comando: &lt;white&gt;gloria]]
        )
      elseif string.starts(&quot;gdcolor&quot;, split[1]) then
        cecho(
          [[

SPAM ti permette di impostare un suffisso e un prefisso per personalizzare il comando gd
Per impostare un prefisso usa il comando: &lt;white&gt;spam gdcolor_prefisso prefisso&lt;gray&gt;
Per impostare un suffisso usa il comando: &lt;white&gt;spam gdcolor_suffisso suffisso&lt;gray&gt;

Ad esempio per ottenere questo risultato: &lt;blue&gt;[&lt;white&gt;Seymour&lt;blue&gt;] dice al gruppo &apos;&lt;yellow&gt;**&lt;cyan&gt;ciao&lt;yellow&gt;**&lt;blue&gt;&apos;.
&lt;gray&gt;Dovresti usare i seguenti comandi
&lt;white&gt;spam gdcolor_prefisso &amp;Y**&amp;C
spam gdcolor_suffisso &amp;Y**&lt;gray&gt;

Per scoprire i TAG colore disponibili in Dei delle Ere usa il comando: &lt;white&gt;aiuto colori&lt;gray&gt;
]]
        )
      else
        cecho(&quot;\nScelta non valida&quot;)
      end
    else
      if string.starts(&quot;ddegroup&quot;, split[1]) then
        persistent_variables[&quot;config&quot;][&quot;dde_group&quot;] = str2bool(split[2])
        checho(&quot;\nDdEGroup: &quot; .. bool2str(persistent_variables[&quot;config&quot;][&quot;dde_group&quot;]))
        save_persistent_var(&quot;config&quot;)
        toggle_ddegroup()
      elseif string.starts(&quot;suoni&quot;, split[1]) then
        persistent_variables[&quot;config&quot;][&quot;sounds&quot;] = str2bool(split[2])
        checho(&quot;\nSuoni: &quot; .. bool2str(persistent_variables[&quot;config&quot;][&quot;sounds&quot;]))
        save_persistent_var(&quot;config&quot;)
      elseif string.starts(&quot;appunti&quot;, split[1]) then
        persistent_variables[&quot;config&quot;][&quot;clipboard&quot;] = str2bool(split[2])
        checho(&quot;\nAppunti: &quot; .. bool2str(persistent_variables[&quot;config&quot;][&quot;clipboard&quot;]))
        save_persistent_var(&quot;config&quot;)
      elseif string.starts(&quot;nascondi_px_persi&quot;, split[1]) then
        persistent_variables[&quot;config&quot;][&quot;hide_lost_experience&quot;] = str2bool(split[2])
        checho(&quot;\nnascondi_px_persi: &quot; .. bool2str(persistent_variables[&quot;config&quot;][&quot;hide_lost_experience&quot;]))
        save_persistent_var(&quot;config&quot;)
      elseif string.starts(&quot;nascondi_scudoni&quot;, split[1]) then
        persistent_variables[&quot;config&quot;][&quot;hide_immune_shield&quot;] = str2bool(split[2])
        checho(&quot;\nnascondi_scudoni: &quot; .. bool2str(persistent_variables[&quot;config&quot;][&quot;hide_immune_shield&quot;]))
        save_persistent_var(&quot;config&quot;)
      elseif string.starts(&quot;gloria&quot;, split[1]) then
        persistent_variables[&quot;config&quot;][&quot;glory_timer&quot;] = str2bool(split[2])
        checho(&quot;\nGloria: &quot; .. bool2str(persistent_variables[&quot;config&quot;][&quot;glory_timer&quot;]))
        save_persistent_var(&quot;config&quot;)
      elseif split[1] == &quot;gdcolor_prefisso&quot; then
        set_char_permanent_var(&quot;gd_start&quot;, removeFirstWord(string))
        checho(&quot;\ngdcolor_prefisso al gd: &quot; .. persistent_variables[character_name][&quot;gd_start&quot;])
      elseif split[1] == &quot;gdcolor_suffisso&quot; then
        set_char_permanent_var(&quot;gd_end&quot;, removeFirstWord(string))
        checho(&quot;\ngdcolor_suffisso al gd: &quot; .. persistent_variables[character_name][&quot;gd_end&quot;])
      else
        cecho(&quot;\nScelta non valida&quot;)
      end
    end
  end
  send(&quot; &quot;)
end

function show_glory_timer()
  send(&quot;gloria&quot;)
  if persistent_variables[&quot;config&quot;][&quot;glory_timer&quot;] == false then
    return
  end
  oneDayAgo = os.time(os.date(&quot;!*t&quot;)) - 24 * 60 * 60
  print(&quot;\nMOB GLORIA NELLE ULTIME 24 ORE:&quot;)
  for key, value in pairs(persistent_variables[character_name][&quot;glory_timer&quot;]) do
    if value &gt; oneDayAgo then
      --print(key .. &quot;: &quot; .. os.date(&quot;%H:%M&quot;, value + 60 * 60))
    else
      persistent_variables[character_name][&quot;glory_timer&quot;][key] = nil
    end
  end
  local array = {}
  makePairs(persistent_variables[character_name][&quot;glory_timer&quot;], array)
  table.sort(array, greater)
  printPairs(array)
  print(&quot;&quot;)
end</script>
        
      <packageName/>
      
      <eventHandlerList>
</eventHandlerList>
      
    </Script>
    <Script isActive="yes" isFolder="no">
        
      <name>profile_initialization</name>
      <script>initialize_persistent_var(&quot;config&quot;)
package_name = &quot;SPAM&quot;
--first profile login
local save_var = false
if persistent_variables[&quot;config&quot;][&quot;sounds&quot;] == nil then
  persistent_variables[&quot;config&quot;][&quot;sounds&quot;] = true
  save_var = true
end
if persistent_variables[&quot;config&quot;][&quot;dde_group&quot;] == nil then
  persistent_variables[&quot;config&quot;][&quot;dde_group&quot;] = true
  save_var = true
end
if persistent_variables[&quot;config&quot;][&quot;glory_timer&quot;] == nil then
  persistent_variables[&quot;config&quot;][&quot;glory_timer&quot;] = true
  save_var = true
end
if persistent_variables[&quot;config&quot;][&quot;hide_lost_experience&quot;] == nil then
  persistent_variables[&quot;config&quot;][&quot;hide_lost_experience&quot;] = true
  save_var = true
end
if persistent_variables[&quot;config&quot;][&quot;hide_immune_shield&quot;] == nil then
  persistent_variables[&quot;config&quot;][&quot;hide_immune_shield&quot;] = true
  save_var = true
end
if persistent_variables[&quot;config&quot;][&quot;clipboard&quot;] == nil then
  persistent_variables[&quot;config&quot;][&quot;clipboard&quot;] = true
  save_var = true
end
if save_var == true then
  save_persistent_var(&quot;config&quot;)
end
ding_file = getMudletHomeDir() .. &quot;/&quot; .. package_name .. &quot;/ding.wav&quot;
character_name = &quot;&quot;
cond = {}
cond[&quot;e&apos; in condizioni superbe&quot;] = 1
cond[&quot;e&apos; in condizioni quasi superbe&quot;] = 2
cond[&quot;e&apos; in eccellenti condizioni&quot;] = 3
cond[&quot;e&apos; in condizioni quasi eccellenti&quot;] = 4
cond[&quot;e&apos; in ottimo stato&quot;] = 5
cond[&quot;e&apos; in buono stato&quot;] = 6
cond[&quot;e&apos; un po&apos; rovinato&quot;] = 7
cond[&quot;e&apos; rovinato&quot;] = 8
cond[&quot;e&apos; molto rovinato&quot;] = 9
cond[&quot;e&apos; in cattivo stato&quot;] = 10
cond[&quot;ha bisogno di riparazioni&quot;] = 11
cond[&quot;e&apos; in condizioni critiche&quot;] = 12
cond[&quot;e&apos; quasi inutilizzabile&quot;] = 13
cond[&quot;sta per cadere a pezzi&quot;] = 14
cond[&quot;e&apos; a pezzi&quot;] = 15
colors =
  {
    &quot;00FF00&quot;,
    &quot;5bf400&quot;,
    &quot;7de800&quot;,
    &quot;96dc00&quot;,
    &quot;aad000&quot;,
    &quot;bbc300&quot;,
    &quot;cab500&quot;,
    &quot;d7a700&quot;,
    &quot;e29700&quot;,
    &quot;eb8700&quot;,
    &quot;f27600&quot;,
    &quot;f86400&quot;,
    &quot;fc4f00&quot;,
    &quot;ff3500&quot;,
    &quot;FF0000&quot;,
  }
-- Contenitore e mini-console per DdE Group
ddeGroupContainer = ddeGroupContainer or Adjustable.Container:new({name = &quot;DdE Group&quot;})
ddeGroupContainer.name = &quot;DdE Group&quot;
ddeGroupContainer:unlockContainer()
ddeGroupWidget =
  ddeGroupWidget or
  Geyser.MiniConsole:new(
    {
      name = &quot;DdE Group&quot;,
      x = 0,
      y = 0,
      autoWrap = true,
      color = &apos;black&apos;,
      scrollBar = false,
      fontSize = 12,
      width = &quot;100%&quot;,
      height = &quot;100%&quot;,
    },
    ddeGroupContainer
  )
clearWindow(&quot;DdE Group&quot;)
ddeGroupWidget:echo(&quot;\r\n*** DdE Group Caricato.\r\n&quot;)
toggle_ddegroup()
class_list = {}
class_list[&quot;Chierico&quot;] = new_class()
class_list[&quot;Chierico&quot;].buff.dps = {&quot;benedizione&quot;, &quot;aiuto divino&quot;}
class_list[&quot;Chierico&quot;].buff.base = {&quot;santificazione&quot;, &quot;volo&quot;}
--class_list[&quot;Chierico&quot;].self_buff.tank = {&quot;protezione dal bene&quot;,&quot;protezione dal male&quot;,&quot;protezione dal fuoco&quot;,&quot;resistenza elettrica&quot;,&quot;protezione dalla energia&quot;,&quot;resistenza risucchio&quot;}
class_list[&quot;Chierico&quot;].heal = {&quot;cura critiche&quot;, &quot;guarigione&quot;, &quot;cure leggere continue&quot;}
class_list[&quot;Chierico&quot;].move = {&quot;nuovo vigore&quot;}
class_list[&quot;Paladino&quot;] = new_class()
class_list[&quot;Paladino&quot;].buff.dps = {&quot;benedizione&quot;}
class_list[&quot;Paladino&quot;].self_buff.tank = {&quot;aura benefica&quot;, &quot;armatura sacra&quot;}
class_list[&quot;Paladino&quot;].self_buff.dps = {&quot;crociata&quot;, &quot;morale&quot;}
class_list[&quot;Paladino&quot;].heal = {&quot;imposizione delle mani&quot;, &quot;martirio&quot;}
class_list[&quot;Paladino&quot;].command = &quot;prega&quot;
class_list[&quot;Oscuro&quot;] = new_class()
class_list[&quot;Oscuro&quot;].self_buff.dps = {&quot;rito oscuro&quot;}
class_list[&quot;Oscuro&quot;].self_buff.base = {&quot;anima fiammeggiante&quot;, &quot;scudo fiammeggiante&quot;}
class_list[&quot;Oscuro&quot;].command = &quot;prega&quot;
class_list[&quot;Mago&quot;] = new_class()
class_list[&quot;Mago&quot;].buff.dps = {&quot;forza&quot;}
class_list[&quot;Mago&quot;].buff.tank = {&quot;scudo&quot;, &quot;armatura&quot;}
class_list[&quot;Mago&quot;].buff.base = {&quot;volo&quot;}
class_list[&quot;Mago&quot;].self_buff.base = {&quot;scudo infuocato&quot;}
class_list[&quot;Mago&quot;].self_buff.tank = {&quot;pelle di pietra&quot;}
class_list[&quot;Mago&quot;].move = {&quot;ristora&quot;}
class_list[&quot;Cercatore&quot;] = new_class()
class_list[&quot;Cercatore&quot;].buff.base = {&quot;santificazione&quot;, &quot;volo&quot;, &quot;agilita felina&quot;}
class_list[&quot;Cercatore&quot;].buff.dps = {&quot;benedizione&quot;, &quot;forza&quot;}
class_list[&quot;Cercatore&quot;].buff.tank = {&quot;scudo&quot;}
class_list[&quot;Cercatore&quot;].self_buff.base = {&quot;scudo di ghiaccio&quot;, &quot;cuore di naria&quot;}
class_list[&quot;Cercatore&quot;].heal = {&quot;cura serie&quot;, &quot;guarigione&quot;, &quot;brezza di naria&quot;}
class_list[&quot;Cercatore&quot;].move = {&quot;ristora&quot;}
class_list[&quot;Vampiro&quot;] = new_class()
class_list[&quot;Vampiro&quot;].buff.dps = {&quot;forza&quot;}
class_list[&quot;Vampiro&quot;].buff.tank = {&quot;scudo&quot;, &quot;tenebre&quot;}
class_list[&quot;Vampiro&quot;].buff.base = {&quot;volo&quot;}
class_list[&quot;Vampiro&quot;].self_buff.tank = {&quot;pelle demoniaca&quot;}
class_list[&quot;Druido&quot;] = new_class()
class_list[&quot;Druido&quot;].buff.base = {&quot;volo&quot;, &quot;agilita felina&quot;}
class_list[&quot;Druido&quot;].self_buff.base = {&quot;scudo di ghiaccio&quot;, &quot;spirito di naria&quot;}
class_list[&quot;Druido&quot;].self_buff.tank = {&quot;pelle del drago&quot;, &quot;pelle di corteccia&quot;}
class_list[&quot;Druido&quot;].heal = {&quot;cura critiche&quot;, &quot;brezza di naria&quot;}
class_list[&quot;Druido&quot;].move = {&quot;nuovo vigore&quot;}
class_list[&quot;Ranger&quot;] = new_class()
class_list[&quot;Ranger&quot;].buff.base = {&quot;agilita felina&quot;}
class_list[&quot;Ranger&quot;].self_buff.dps = {&quot;ferocia animale&quot;}
class_list[&quot;Ranger&quot;].self_buff.tank = {&quot;pelle di corteccia&quot;}
class_list[&quot;Ranger&quot;].heal = {&quot;cura critiche&quot;}
class_list[&quot;Ranger&quot;].move = {&quot;nuovo vigore&quot;}
class_list[&quot;Psionico&quot;] = new_class()
class_list[&quot;Psionico&quot;].buff.base = {&quot;levitazione&quot;}
class_list[&quot;Psionico&quot;].self_buff.base = {&quot;scudo di energia&quot;}
class_list[&quot;Psionico&quot;].self_buff.dps = {&quot;forza psionica&quot;}
class_list[&quot;Psionico&quot;].self_buff.tank = {&quot;scudo mentale&quot;, &quot;sfera protettiva&quot;}
class_list[&quot;Psionico&quot;].heal = {&quot;nostrum&quot;}
class_list[&quot;Psionico&quot;].command = &quot;pensa&quot;
class_list[&quot;Necromante&quot;] = new_class()
class_list[&quot;Necromante&quot;].buff.base = {&quot;levitazione&quot;}
class_list[&quot;Necromante&quot;].buff.tank = {&quot;tenebre&quot;}
class_list[&quot;Necromante&quot;].self_buff.base = {&quot;scudo di ossa&quot;}
class_list[&quot;Necromante&quot;].self_buff.tank = {&quot;armatura di ombra&quot;, &quot;pegno dei vinti&quot;}
class_list[&quot;Necromante&quot;].command = &quot;evoc&quot;
class_list[&quot;Necromante&quot;].move = {&quot;ristora&quot;}</script>
        
      <packageName/>
      
      <eventHandlerList>
</eventHandlerList>
      
    </Script>
    <Script isActive="yes" isFolder="no">
        
      <name>gmcp_loop</name>
      <script>function gmcp_loop()
  --incomplete login
  if
    gmcp.Char.Vitals == nil or
    gmcp.Char.Magie == nil or
    gmcp.Char.Name == nil or
    gmcp.Char.Classi.classi == nil
  then
    return
  end
  --character loading
  if character_name ~= gmcp.Char.Name.name then
    character_name = gmcp.Char.Name.name
    initialize_persistent_var(character_name)
    observe_spell_list = nil
    --first character login
    local save_var = false
    if persistent_variables[character_name][&quot;observe_list&quot;] == nil then
      persistent_variables[character_name][&quot;observe_list&quot;] = {}
      save_var = true
    end
    if persistent_variables[character_name][&quot;optional_buff&quot;] == nil then
      persistent_variables[character_name][&quot;optional_buff&quot;] = {}
      save_var = true
    end
    if persistent_variables[character_name][&quot;gd_start&quot;] == nil then
      persistent_variables[character_name][&quot;gd_start&quot;] = &quot;&quot;
      save_var = true
    end
    if persistent_variables[character_name][&quot;gd_end&quot;] == nil then
      persistent_variables[character_name][&quot;gd_end&quot;] = &quot;&quot;
      save_var = true
    end
    if persistent_variables[character_name][&quot;glory_timer&quot;] == nil then
      persistent_variables[character_name][&quot;glory_timer&quot;] = {}
      save_var = true
    end
    if save_var == true then
      save_persistent_var(character_name)
    end
    --return needed to refresh classes
    gmcp.Char.Classi.classi = nil
    return
  end
  --party observer
  if persistent_variables[&quot;config&quot;][&quot;dde_group&quot;] == true then
    clearWindow(&quot;DdE Group&quot;)
    if gmcp.Char.Gruppo == nil or gmcp.Char.Gruppo.gruppo == nil then
      --if not in group, create a similar structure to show player info
      gruppo = {}
      gruppo[1] = {}
      gruppo[1].nome = gmcp.Char.Name.name
      gruppo[1].hp = math.floor(100 * gmcp.Char.Vitals.hp / gmcp.Char.Vitals.maxhp)
      gruppo[1].move = math.floor(100 * gmcp.Char.Vitals.move / gmcp.Char.Vitals.maxmove)
      gruppo[1].incantesimi = {}
      if gmcp.Char.Magie.incantesimi ~= nil then
        for i, v in ipairs(gmcp.Char.Magie.incantesimi) do
          table.insert(gruppo[1].incantesimi, v.nome)
        end
      end
    else
      gruppo = gmcp.Char.Gruppo.gruppo
    end
    --generate the observable spell list
    if observe_spell_list == nil then
      gen_spell_list(gmcp.Char.Classi.classi)
    end
    --generate the persistent_variables[character_name][&quot;optional_buff&quot;] entry for current character, if missing
    if persistent_variables[character_name][&quot;optional_buff&quot;] == nil then
      persistent_variables[character_name][&quot;optional_buff&quot;] = {}
    end
    --if not otherwise specifies, i&apos;m always in base observe mode
    if persistent_variables[character_name][&quot;observe_list&quot;][character_name] == nil then
      persistent_variables[character_name][&quot;observe_list&quot;][character_name] = &quot;base&quot;
    end
    --group loop
    party_names = {}
    for i, v in ipairs(gruppo) do
      local this_name = beautifyName(v.nome)
      name_x = 2
      while party_names[this_name] ~= nil do
        if name_x &gt; 2 then
          this_name = string.gsub(this_name, (name_x - 1) .. &quot;.&quot;, &quot;&quot;)
        end
        this_name = name_x .. &quot;.&quot; .. this_name
        name_x = name_x + 1
      end
      party_names[this_name] = true
      ddeGroupWidget:decho(&quot;\n&quot;)
      local ob_func_list = {}
      local ob_name_list = role_list()
      table.foreach(
        ob_name_list,
        function(k1, v1)
          table.insert(
            ob_func_list,
            function()
              ob_role(this_name, v1, false)
            end
          )
        end
      )
      ddeGroupWidget:hechoPopup(this_name, ob_func_list, ob_name_list, true)
      ddeGroupWidget:decho(&quot;(&quot;)
      this_hp = tonumber(v.hp)
      row = &quot;#&quot; .. getPFcolor(this_hp, 100) .. this_hp
      --if player can cast heal spells, add them as link
      if next(observe_spell_list.heal) ~= nil then
        heal_func_list = {}
        table.foreach(
          observe_spell_list.heal,
          function(k1, v1)
            table.insert(
              heal_func_list,
              function()
                send(observe_spell_list.command .. &quot; &apos;&quot; .. v1 .. &quot;&apos; &quot; .. this_name)
              end
            )
          end
        )
        ddeGroupWidget:hechoPopup(row, heal_func_list, observe_spell_list.heal, true)
      else
        ddeGroupWidget:hecho(row)
      end
      ddeGroupWidget:decho(&quot;&lt;200,200,200&gt;&quot;)
      this_move = tonumber(v.move)
      if this_move &lt;= 20 then
        row = &quot;, &lt;red&gt;&quot; .. this_move
        if next(observe_spell_list.move) ~= nil then
          move_func_list = {}
          table.foreach(
            observe_spell_list.move,
            function(k1, v1)
              table.insert(
                move_func_list,
                function()
                  send(observe_spell_list.command .. &quot; &apos;&quot; .. v1 .. &quot;&apos; &quot; .. this_name)
                end
              )
            end
          )
          ddeGroupWidget:cechoPopup(row, move_func_list, observe_spell_list.move, true)
        else
          ddeGroupWidget:cecho(row)
        end
      end
      ddeGroupWidget:decho(&quot;)&quot;)
      --generate spell to check for the current group member
      if persistent_variables[character_name][&quot;observe_list&quot;][this_name] ~= nil then
        observe_spell = {}
        merge_tables(observe_spell_list.buff.base, observe_spell)
        if this_name == character_name then
          merge_tables(observe_spell_list.self_buff.base, observe_spell)
        end
        if string.find(persistent_variables[character_name][&quot;observe_list&quot;][this_name], &quot;tank&quot;) then
          merge_tables(observe_spell_list.buff.tank, observe_spell)
          if this_name == character_name then
            merge_tables(observe_spell_list.self_buff.tank, observe_spell)
          end
        end
        if string.find(persistent_variables[character_name][&quot;observe_list&quot;][this_name], &quot;dps&quot;) then
          merge_tables(observe_spell_list.buff.dps, observe_spell)
          if this_name == character_name then
            merge_tables(observe_spell_list.self_buff.dps, observe_spell)
          end
        end
        if persistent_variables[character_name][&quot;optional_buff&quot;][this_name] ~= nil then
          for key, val in pairs(persistent_variables[character_name][&quot;optional_buff&quot;][this_name]) do
            if val == true then
              table.insert(observe_spell, key)
            end
          end
        end
        deduplicate(observe_spell)
        spells = nil
        spells = v.incantesimi
        if spells ~= nil then
          active = nil
          active = {}
          for n = 1, #spells do
            active[spells[n]] = true
          end
          --races with implicit fly spell
          if
            v.razza == &quot;efreet&quot; or
            v.razza == &quot;gigante delle nuvole&quot; or
            v.razza == &quot;gigante delle tempeste&quot;
          then
            active[&quot;volo&quot;] = true
          end
          --races with implicit fireshield spell
          if v.razza == &quot;efreet&quot; or v.razza == &quot;azer&quot; then
            active[&quot;scudo infuocato&quot;] = true
          end
          --spell overrides
          if active[&quot;volo di gruppo&quot;] or active[&quot;fly&quot;] then
            active[&quot;volo&quot;] = true
          end
          if active[&quot;aura sacra&quot;] or active[&quot;i guerrieri del cielo&quot;] then
            --TODO gestione della sant del bardo: i guerrieri del cielo
            active[&quot;santificazione&quot;] = true
          end
          if active[&quot;volo&quot;] then
            active[&quot;levitazione&quot;] = true
          end
          if active[&quot;protezione dal bene&quot;] then
            active[&quot;protezione dal male&quot;] = true
          end
          if active[&quot;protezione dal male&quot;] then
            active[&quot;protezione dal bene&quot;] = true
          end
          active_observed = {}
          for a, b in ipairs(observe_spell) do
            if not active[b] then
              ddeGroupWidget:decho(&quot; - &quot;)
              ddeGroupWidget:dechoLink(
                b,
                function()
                  send(observe_spell_list.command .. &quot; &apos;&quot; .. b .. &quot;&apos; &quot; .. this_name)
                end,
                &quot;Casta &quot; .. b,
                true
              )
            else
              active_observed[b] = true
            end
          end
          if gmcp.Char.Magie.incantesimi ~= nil and this_name == character_name then
            for a, b in ipairs(gmcp.Char.Magie.incantesimi) do
              if active_observed[b.nome] == true and b.durata &lt; 20 then
                if b.durata &gt; 10 then
                  color_tag = &quot;&lt;255,255,0&gt;&quot;
                else
                  color_tag = &quot;&lt;255,0,0&gt;&quot;
                end
                if b.nome == &quot;volo&quot; or b.nome == &quot;branchie&quot; or b.nome == &quot;levitazione&quot; then
                  ddeGroupWidget:dechoLink(
                    &quot; - &quot; .. color_tag .. b.nome .. &quot;&lt;200,200,200&gt;&quot;,
                    function()
                      send(observe_spell_list.command .. &quot; &apos;&quot; .. b.nome .. &quot;&apos; &quot; .. this_name)
                    end,
                    &quot;Casta &quot; .. b.nome,
                    true
                  )
                else
                  ddeGroupWidget:decho(&quot; - &quot; .. color_tag .. b.nome .. &quot;&lt;200,200,200&gt;&quot;)
                end
              end
            end
          end
        end
      end
      ddeGroupWidget:decho(&quot;\n&quot;)
      observe_spell = nil
      active_observed = nil
    end
    --delete_table(gruppo)
  end
end</script>
        
      <packageName/>
      
      <eventHandlerList>
        
        <string>gmcp.Char</string>
        
      </eventHandlerList>
      
    </Script>
    
  </ScriptPackage>
  <AliasPackage>
    <Alias isActive="yes" isFolder="no">
        
      <name>main_help</name>
      <script>spam_main(matches[3])</script>
        
      <command/>
        
      <packageName/>
        
      <regex>^(spam|SPAM)(.+|)$</regex>
      
    </Alias>
    <Alias isActive="yes" isFolder="no">
        
      <name>glory_timer</name>
      <script>show_glory_timer()</script>
        
      <command/>
        
      <packageName/>
        
      <regex>^glo(|r|ri|ria)$</regex>
      
    </Alias>
    <Alias isActive="yes" isFolder="no">
        
      <name>gd</name>
      <script>send(&quot;gd &quot; .. persistent_variables[character_name][&quot;gd_start&quot;] .. matches[3] .. persistent_variables[character_name][&quot;gd_end&quot;] .. &quot;&amp;d&quot;)</script>
        
      <command/>
        
      <packageName/>
        
      <regex>^(gd|GD|gt|GT) (.+)$</regex>
      
    </Alias>
    <Alias isActive="yes" isFolder="no">
        
      <name>observe</name>
      <script>local help_string =
  [[

Questo è l&apos;aiuto per l&apos;alias observe del package BuffObserver
Il comando è abbreviabile con ob.
Se vuoi monitorare i buff di un alleato usa: observe nome ruolo
I ruoli ammessi sono: base, tank, dps, tankdps, remove (rimuove l&apos;alleato)
Per visionare tutti gli alleati in observe usa: observe list
Per svuotare la lista degli alleati in observe usa: observe clear
Per aggiungere un buff optionale usa: observe optionalbuff alleato cast

]]
local roles = {&quot;remove&quot;, &quot;base&quot;, &quot;tank&quot;, &quot;dps&quot;, &quot;tankdps&quot;, &quot;dpstank&quot;}
local role = &quot;&quot;
local split = explode(matches[3])
if #split == 1 then
  if string.starts(&quot;list&quot;, string.lower(split[1])) then
    echo(&quot;\nLista observe:&quot;)
    display(persistent_variables[character_name][&quot;observe_list&quot;])
    return
  end
  if string.starts(&quot;clear&quot;, string.lower(split[1])) then
    persistent_variables[character_name][&quot;observe_list&quot;] = nil
    persistent_variables[character_name][&quot;observe_list&quot;] = {}
    save_persistent_var(character_name)
    echo(&quot;\nLista observe svuotata&quot;)
    send(&quot;\n&quot;)
    return
  end
end
if #split &gt; 1 then
  if string.starts(&quot;optionalbuff&quot;, string.lower(split[1])) then
    allyName = getAllyName(split[2])
    if allyName == nil then
      cecho(&quot;\n&lt;red&gt;Nessun alleato trovato per &quot; .. split[2])
      echo(&quot;\nLa sintassi corretta è: observe optionalbuff alleato cast\n&quot;)
      send(&quot;\n&quot;)
      return
    end
    if persistent_variables[character_name][&quot;optional_buff&quot;][allyName] == nil then
      persistent_variables[character_name][&quot;optional_buff&quot;][allyName] = {}
    end
    buff = removeFirstTwoWords(matches[3])
    if persistent_variables[character_name][&quot;optional_buff&quot;][allyName][buff] == true then
      echo(&quot;\nRimuovo &quot; .. buff .. &quot; per &quot; .. allyName .. &quot;\n&quot;)
      persistent_variables[character_name][&quot;optional_buff&quot;][allyName][buff] = nil
    else
      echo(&quot;\nOsservo &quot; .. buff .. &quot; per &quot; .. allyName .. &quot;\n&quot;)
      persistent_variables[character_name][&quot;optional_buff&quot;][allyName][buff] = true
    end
    send(&quot;\n&quot;)
    save_persistent_var(character_name)
    return
  end
  if ob_role(split[1], split[2], true) then
    return
  end
end
checho(help_string)</script>
        
      <command/>
        
      <packageName/>
        
      <regex>^(observe|ob)(.+|)$</regex>
      
    </Alias>
    
  </AliasPackage>
  <TimerPackage>
</TimerPackage>
  <TriggerPackage>
    <TriggerGroup isActive="yes" isFolder="yes" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isColorTrigger="" isColorTriggerFg="" isColorTriggerBg="">
        
      <name>utility</name>
      <script/>
        
      <triggerType>0</triggerType>
        
      <conditonLineDelta>0</conditonLineDelta>
        
      <mStayOpen>0</mStayOpen>
        
      <mCommand/>
        
      <packageName/>
        
      <path/>
        
      <mFgColor>#ff0000</mFgColor>
        
      <mBgColor>#ffff00</mBgColor>
        
      <mSoundFile/>
        
      <colorTriggerFgColor>#000000</colorTriggerFgColor>
        
      <colorTriggerBgColor>#000000</colorTriggerBgColor>
      <regexCodeList>
</regexCodeList>
      <regexCodePropertyList>
</regexCodePropertyList>
      <Trigger isActive="yes" isFolder="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isColorTrigger="" isColorTriggerFg="" isColorTriggerBg="">
          
        <name>prompt_color</name>
        <script>max=tonumber(matches[3])
current=tonumber(matches[2])
ratio=current/max
selectString( matches[2], 1 )
if ratio==1 then fg(&quot;green&quot;)
elseif ratio&gt;0.9 then setFgColor(51, 204, 51)
elseif ratio&gt;0.7 then setFgColor(115, 230, 0)
elseif ratio&gt;0.4 then fg(&quot;yellow&quot;)
elseif ratio&gt;0.2 then setFgColor(255, 153, 0)
else fg(&quot;red&quot;) end
resetFormat()</script>
          
        <triggerType>0</triggerType>
          
        <conditonLineDelta>0</conditonLineDelta>
          
        <mStayOpen>0</mStayOpen>
          
        <mCommand/>
          
        <packageName/>
          
        <path/>
          
        <mFgColor>#ff0000</mFgColor>
          
        <mBgColor>#ffff00</mBgColor>
          
        <mSoundFile/>
          
        <colorTriggerFgColor>#000000</colorTriggerFgColor>
          
        <colorTriggerBgColor>#000000</colorTriggerBgColor>
        <regexCodeList>
          
          <string>^PF:(.+?)\/(.+?) (.+)$</string>
          
          <string>^Pf:(.+?)\/(.+?) (.+)$</string>
          
          <string>^PF: (.+?)\/(.+?) (.+)$</string>
          
          <string>^Pf: (.+?)\/(.+?) (.+)$</string>
        </regexCodeList>
        <regexCodePropertyList>
          
          <integer>1</integer>
          
          <integer>1</integer>
          
          <integer>1</integer>
          
          <integer>1</integer>
        </regexCodePropertyList>
        
      </Trigger>
      <Trigger isActive="yes" isFolder="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isColorTrigger="" isColorTriggerFg="" isColorTriggerBg="">
          
        <name>item_color</name>
        <script>if cond[matches[4]]~= nil then
  thiscolor=colors[cond[matches[4]]]
else
  thiscolor=&quot;FF33DA&quot;
end

selectString( matches[4], 1 )

setHexFgColor(thiscolor)
resetFormat()</script>
          
        <triggerType>0</triggerType>
          
        <conditonLineDelta>0</conditonLineDelta>
          
        <mStayOpen>0</mStayOpen>
          
        <mCommand/>
          
        <packageName/>
          
        <path/>
          
        <mFgColor>#ff0000</mFgColor>
          
        <mBgColor>#ffff00</mBgColor>
          
        <mSoundFile/>
          
        <colorTriggerFgColor>#000000</colorTriggerFgColor>
          
        <colorTriggerBgColor>#000000</colorTriggerBgColor>
        <regexCodeList>
          
          <string>^\[(.+?)\] (.+) \.\.(.+)\.( \[.+\]|)( \(Eterno\)|)$</string>
          
          <string>^&lt;(.+?)&gt;(.+) \.\.(.+)\.( \(Eterno\)|)$</string>
        </regexCodeList>
        <regexCodePropertyList>
          
          <integer>1</integer>
          
          <integer>1</integer>
        </regexCodePropertyList>
        
      </Trigger>
      <Trigger isActive="yes" isFolder="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isColorTrigger="" isColorTriggerFg="" isColorTriggerBg="">
          
        <name>auto_trasf</name>
        <script/>
          
        <triggerType>0</triggerType>
          
        <conditonLineDelta>0</conditonLineDelta>
          
        <mStayOpen>0</mStayOpen>
          
        <mCommand>ind tutto</mCommand>
          
        <packageName/>
          
        <path/>
          
        <mFgColor>#ff0000</mFgColor>
          
        <mBgColor>#ffff00</mBgColor>
          
        <mSoundFile/>
          
        <colorTriggerFgColor>#000000</colorTriggerFgColor>
          
        <colorTriggerBgColor>#000000</colorTriggerBgColor>
        <regexCodeList>
          
          <string>Ritorni al tuo corpo originario.</string>
          
          <string>Stai assumendo le sembianze</string>
        </regexCodeList>
        <regexCodePropertyList>
          
          <integer>0</integer>
          
          <integer>0</integer>
        </regexCodePropertyList>
        
      </Trigger>
      <Trigger isActive="yes" isFolder="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isColorTrigger="" isColorTriggerFg="" isColorTriggerBg="">
          
        <name>fast_login</name>
        <script/>
          
        <triggerType>0</triggerType>
          
        <conditonLineDelta>0</conditonLineDelta>
          
        <mStayOpen>0</mStayOpen>
          
        <mCommand>1</mCommand>
          
        <packageName/>
          
        <path/>
          
        <mFgColor>#ff0000</mFgColor>
          
        <mBgColor>#ffff00</mBgColor>
          
        <mSoundFile/>
          
        <colorTriggerFgColor>#000000</colorTriggerFgColor>
          
        <colorTriggerBgColor>#000000</colorTriggerBgColor>
        <regexCodeList>
          
          <string> Laine sino all&apos;algido sperone</string>
          
          <string>1) Entra nel MUD</string>
          
          <string>Telegram: https://t.me/ddemud</string>
        </regexCodeList>
        <regexCodePropertyList>
          
          <integer>0</integer>
          
          <integer>0</integer>
          
          <integer>0</integer>
        </regexCodePropertyList>
        
      </Trigger>
      <Trigger isActive="yes" isFolder="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isColorTrigger="" isColorTriggerFg="" isColorTriggerBg="">
          
        <name>auto_save</name>
        <script/>
          
        <triggerType>0</triggerType>
          
        <conditonLineDelta>0</conditonLineDelta>
          
        <mStayOpen>0</mStayOpen>
          
        <mCommand>salva</mCommand>
          
        <packageName/>
          
        <path/>
          
        <mFgColor>#ff0000</mFgColor>
          
        <mBgColor>#ffff00</mBgColor>
          
        <mSoundFile/>
          
        <colorTriggerFgColor>#000000</colorTriggerFgColor>
          
        <colorTriggerBgColor>#000000</colorTriggerBgColor>
        <regexCodeList>
          
          <string>^Ricevi (.+) punti esperienza.$</string>
        </regexCodeList>
        <regexCodePropertyList>
          
          <integer>1</integer>
        </regexCodePropertyList>
        
      </Trigger>
      <Trigger isActive="yes" isFolder="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isColorTrigger="" isColorTriggerFg="" isColorTriggerBg="">
          
        <name>beep</name>
        <script>play_sound(ding_file)</script>
          
        <triggerType>0</triggerType>
          
        <conditonLineDelta>0</conditonLineDelta>
          
        <mStayOpen>0</mStayOpen>
          
        <mCommand/>
          
        <packageName/>
          
        <path/>
          
        <mFgColor>#ff0000</mFgColor>
          
        <mBgColor>#ffff00</mBgColor>
          
        <mSoundFile/>
          
        <colorTriggerFgColor>#000000</colorTriggerFgColor>
          
        <colorTriggerBgColor>#000000</colorTriggerBgColor>
        <regexCodeList>
          
          <string>vuole la tua attenzione.</string>
        </regexCodeList>
        <regexCodePropertyList>
          
          <integer>0</integer>
        </regexCodePropertyList>
        
      </Trigger>
      <Trigger isActive="yes" isFolder="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isColorTrigger="" isColorTriggerFg="" isColorTriggerBg="">
          
        <name>no_disconnect</name>
        <script/>
          
        <triggerType>0</triggerType>
          
        <conditonLineDelta>0</conditonLineDelta>
          
        <mStayOpen>0</mStayOpen>
          
        <mCommand>guarda</mCommand>
          
        <packageName/>
          
        <path/>
          
        <mFgColor>#ff0000</mFgColor>
          
        <mBgColor>#ffff00</mBgColor>
          
        <mSoundFile/>
          
        <colorTriggerFgColor>#000000</colorTriggerFgColor>
          
        <colorTriggerBgColor>#000000</colorTriggerBgColor>
        <regexCodeList>
          
          <string>Scompari nel vuoto.</string>
        </regexCodeList>
        <regexCodePropertyList>
          
          <integer>0</integer>
        </regexCodePropertyList>
        
      </Trigger>
      <Trigger isActive="yes" isFolder="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isColorTrigger="" isColorTriggerFg="" isColorTriggerBg="">
          
        <name>hide_lost_experience</name>
        <script>if persistent_variables[&quot;config&quot;][&quot;hide_lost_experience&quot;] == true then
  deleteLine()
end</script>
          
        <triggerType>0</triggerType>
          
        <conditonLineDelta>0</conditonLineDelta>
          
        <mStayOpen>0</mStayOpen>
          
        <mCommand/>
          
        <packageName/>
          
        <path/>
          
        <mFgColor>#ff0000</mFgColor>
          
        <mBgColor>#ffff00</mBgColor>
          
        <mSoundFile/>
          
        <colorTriggerFgColor>#000000</colorTriggerFgColor>
          
        <colorTriggerBgColor>#000000</colorTriggerBgColor>
        <regexCodeList>
          
          <string>Tanta fatica per niente......</string>
          
          <string>Devi andare in gilda per livellare il prima possibile</string>
        </regexCodeList>
        <regexCodePropertyList>
          
          <integer>0</integer>
          
          <integer>0</integer>
        </regexCodePropertyList>
        
      </Trigger>
      <Trigger isActive="yes" isFolder="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isColorTrigger="" isColorTriggerFg="" isColorTriggerBg="">
          
        <name>hide_immune_shield</name>
        <script>if persistent_variables[&quot;config&quot;][&quot;hide_immune_shield&quot;] == true then
  deleteLine()
end</script>
          
        <triggerType>0</triggerType>
          
        <conditonLineDelta>0</conditonLineDelta>
          
        <mStayOpen>0</mStayOpen>
          
        <mCommand/>
          
        <packageName/>
          
        <path/>
          
        <mFgColor>#ff0000</mFgColor>
          
        <mBgColor>#ffff00</mBgColor>
          
        <mSoundFile/>
          
        <colorTriggerFgColor>#000000</colorTriggerFgColor>
          
        <colorTriggerBgColor>#000000</colorTriggerBgColor>
        <regexCodeList>
          
          <string>^Le schegge (.+) stavano quasi per invest(.+)!$</string>
          
          <string>^Le fiamme (.+) stavano quasi per invest(.+)!$</string>
          
          <string>^Le ossa (.+) stavano quasi per invest(.+)!$</string>
          
          <string>^Le onde di energia (.+) stavano quasi per invest(.+)!$</string>
        </regexCodeList>
        <regexCodePropertyList>
          
          <integer>1</integer>
          
          <integer>1</integer>
          
          <integer>1</integer>
          
          <integer>1</integer>
        </regexCodePropertyList>
        
      </Trigger>
      
    </TriggerGroup>
    <TriggerGroup isActive="yes" isFolder="yes" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isColorTrigger="" isColorTriggerFg="" isColorTriggerBg="">
        
      <name>glory_timer</name>
      <script/>
        
      <triggerType>0</triggerType>
        
      <conditonLineDelta>0</conditonLineDelta>
        
      <mStayOpen>0</mStayOpen>
        
      <mCommand/>
        
      <packageName/>
        
      <path/>
        
      <mFgColor>#ff0000</mFgColor>
        
      <mBgColor>#ffff00</mBgColor>
        
      <mSoundFile/>
        
      <colorTriggerFgColor>#000000</colorTriggerFgColor>
        
      <colorTriggerBgColor>#000000</colorTriggerBgColor>
      <regexCodeList>
</regexCodeList>
      <regexCodePropertyList>
</regexCodePropertyList>
      <Trigger isActive="yes" isFolder="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isColorTrigger="" isColorTriggerFg="" isColorTriggerBg="">
          
        <name>last_dead</name>
        <script>lastDead = matches[2]</script>
          
        <triggerType>0</triggerType>
          
        <conditonLineDelta>0</conditonLineDelta>
          
        <mStayOpen>0</mStayOpen>
          
        <mCommand/>
          
        <packageName/>
          
        <path/>
          
        <mFgColor>#ff0000</mFgColor>
          
        <mBgColor>#ffff00</mBgColor>
          
        <mSoundFile/>
          
        <colorTriggerFgColor>#000000</colorTriggerFgColor>
          
        <colorTriggerBgColor>#000000</colorTriggerBgColor>
        <regexCodeList>
          
          <string>^(.+) e&apos; mort(o|a)!!$</string>
        </regexCodeList>
        <regexCodePropertyList>
          
          <integer>1</integer>
        </regexCodePropertyList>
        
      </Trigger>
      <Trigger isActive="yes" isFolder="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isColorTrigger="" isColorTriggerFg="" isColorTriggerBg="">
          
        <name>got_glory</name>
        <script>if lastDead == nil or lastDead == &apos;&apos; then
  return
end
persistent_variables[character_name][&quot;glory_timer&quot;][lastDead] = os.time(os.date(&quot;!*t&quot;))
save_persistent_var(character_name)</script>
          
        <triggerType>0</triggerType>
          
        <conditonLineDelta>0</conditonLineDelta>
          
        <mStayOpen>0</mStayOpen>
          
        <mCommand/>
          
        <packageName/>
          
        <path/>
          
        <mFgColor>#ff0000</mFgColor>
          
        <mBgColor>#ffff00</mBgColor>
          
        <mSoundFile/>
          
        <colorTriggerFgColor>#000000</colorTriggerFgColor>
          
        <colorTriggerBgColor>#000000</colorTriggerBgColor>
        <regexCodeList>
          
          <string>gloria per questa uccisione!</string>
        </regexCodeList>
        <regexCodePropertyList>
          
          <integer>0</integer>
        </regexCodePropertyList>
        
      </Trigger>
      
    </TriggerGroup>
    <Trigger isActive="yes" isFolder="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isColorTrigger="" isColorTriggerFg="" isColorTriggerBg="">
        
      <name>clipboard</name>
      <script>string2clipboard = &quot;&quot;</script>
        
      <triggerType>0</triggerType>
        
      <conditonLineDelta>0</conditonLineDelta>
        
      <mStayOpen>0</mStayOpen>
        
      <mCommand/>
        
      <packageName/>
        
      <path/>
        
      <mFgColor>#ff0000</mFgColor>
        
      <mBgColor>#ffff00</mBgColor>
        
      <mSoundFile/>
        
      <colorTriggerFgColor>#000000</colorTriggerFgColor>
        
      <colorTriggerBgColor>#000000</colorTriggerBgColor>
      <regexCodeList>
        
        <string>^L&apos;oggetto &apos;(.+)$</string>
        
        <string>^(.+)appartiene alla razza(.+)$</string>
      </regexCodeList>
      <regexCodePropertyList>
        
        <integer>1</integer>
        
        <integer>1</integer>
      </regexCodePropertyList>
      <Trigger isActive="yes" isFolder="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isColorTrigger="" isColorTriggerFg="" isColorTriggerBg="">
          
        <name>line parser</name>
        <script/>
          
        <triggerType>0</triggerType>
          
        <conditonLineDelta>0</conditonLineDelta>
          
        <mStayOpen>0</mStayOpen>
          
        <mCommand/>
          
        <packageName/>
          
        <path/>
          
        <mFgColor>#ff0000</mFgColor>
          
        <mBgColor>#ffff00</mBgColor>
          
        <mSoundFile/>
          
        <colorTriggerFgColor>#000000</colorTriggerFgColor>
          
        <colorTriggerBgColor>#000000</colorTriggerBgColor>
        <regexCodeList>
          
          <string>^.*$</string>
        </regexCodeList>
        <regexCodePropertyList>
          
          <integer>1</integer>
        </regexCodePropertyList>
        
      </Trigger>
      
    </Trigger>
    
  </TriggerPackage>
  <KeyPackage>
</KeyPackage>
</MudletPackage>
